#include <iostream>
#include <locale.h>

using namespace std;

int main()
{
    setlocale(LC_ALL, "rus");
    /* Иерархия типов данных:

    Типы данных и их иерархия определяются не только в байтах, но и по размеру их содержимого, и по количеству. Типы данных характеризуются по объёму хранимых данных,
    т.е. по макс.значениям, которые они могут хранить. Самый маленький тип данных это логический, занимает 1 байт, принимает значения лишь true/false.

    Следующий по старшенству - символьный (char), одиночный символ, один значок             ---!!!---ДОБАВЬ СКОЛЬКО КАЖДЫЙ ЗАНИМАЕТ В БАЙТАХ---!!!---
    следующий short занимает 2 байта
    следующий unsigned short (!) беззнаковая форма записи на ступеньку старше
    следующий int
    следующий unsigned int
    следующий long
    следующий unsigned long
    следующий long int занимает 8 байт
    следующий unsigned long int
    следующий long long
    следующий unsigned long long
    следующий float занимает 4 байта                                                         // (!) - у вещественных нет беззнаковости!
    следующий double занимает 8 байт
    следующий long double

    Зачем нужна иерархия?
    В некоторых ситуациях происходит преобразование типов данных, когда в одном выражении встречается два разных типа данных, например при присваивании (=)!

           Преобразования бывают двух видов, по диапазону значений, и по способу осуществления преобразований:

        1. По диапазону значений - сужающие и расширяющие.
            * сужающие - от старшего типа данных к младшему, например от double к float. Оно может приводить к потерям данных.
            * расширяющие - от младшего к старшему, например от bool к int. Данное преобразование почти никогда не приводит к потере данных.
                (символьный тип данных тоже легко преобразовывается к целому или дробному числу. Это не вызывает ошибок у компилятора, но это не всегда корректно).
                (!) добавление приставки unsigned может приниматься расширяющим преобразованием в его положительную сторону.

        2. По способу осуществления преобразований.
            * неявные - выполняются компилятором самостоятельно
            * явные - мы преобразуем сами */

            // Сужающее преобразование

    int A = 3000000000;                                                     // число преобразуется в long long из-за своего размера
    cout << "A=" << A << endl;                                              // пройдет усечение, т.к. 3000000000 > 4 байтов. Это неявное сужающее преобразование

    unsigned int B = 3000000000;                                            // тоже неявное преобразование, но уже неразличное по содержимому, и в А может поместиться
    cout << "B=" << B << endl;                                              // все число 3000000000

    // Расширяющее преобразование

    double C = 3;                                                           // неявное расширяющее преобразование от int к double
    float D = 3.14;                                                         // неявное сужающее преобразование от double во float с потерей данных в округлении

    /*
    int E = { 3.94 };                                                       // неявное сужающее преобразование от double к int
    cout << "E=" << E << endl;                                              // (!) УИ выдаст ошибку о необходимости явного преобразования и остановит запуск
    F = { D / C };                                                          // (!) унифицированная форма присваивания тоже выдаст ошибку
    */
    // (!) важно правильно использовать соответствующие типы данных!
    int F = 10;
    int G = 3;


    // Преобразование типов данных в вырожениях.

    cout << "F/G=" << F / G << endl;                                        // int / int = int!
    double H = F / G;                                                       // интовый результат запишется в переменную типа double в виде 3.0
    cout << "H=" << H << endl;
    /* Тоже только 3, т.к. мы делим int на int и помещаем результат в "H", а результат выражения есть тот же int, т.к. нам не важно куда мы этот результат поместим.
    "H" это просто хранилище. Разве что "Н" стала теперь 3.0, т.к. преобразовалась в double.

    Если мы в выражении встречаем разные типы данных, то результат этого выражения будет иметь старший тип данных из участвующих в нем. Но на экране все равно будет 3,
    т.к. на экране ноль будет отброшен. Ноль не пишется на экране, но хранится будет как 3.0.

    Если в выражении учавствуют несколько типов данных, которые нельзя изменить, например F и G д/б целые, а Н вещественная, достаточно преобразовать лишь одну из них.

    Например:

    int - float + short * bool
        2       3       1       (порядок выполнения вычислений)
    1: short * bool = short
    2: int - float = float
    3: float + short = float

    След, если в каком-то большом выражении сошлись разные типы данных, то общий результат всегда будет иметь самый старший тип данных независимо от количества мат.
    операций сложения, умношжения, деления... Также и с другими операторами. Когда они видят в выражении два, три,... типа данных, то всегда преобразуют к самому стар-
    шему из них.

    Чтобы преобразовать переменную к нужному типу данных нужно выполнить явное преобразование - перед переменной в круглых скобках указать нужный тип данных,
    в нашем примере (double). */
    int I = 10;
    int J = 3;
    cout << "I/J=" << (double)I / J << endl;                                // можем и во float, лишь бы было вещ.число (double / int = double)
                                                                            // (double)I - явное преобразование значения переменной I в тип данных double
    double K = I / J;
    cout << "K=" << K << endl;
    /* (!) как мы все ещё видим переменная К, представляющая собой действие деления, не стала дробной, а по прежнему целое число, т.к. явное преобразование действует
    только там где мы его используем и действует только на значение переменной. Сама переменная при этом остается быть int.

    След, для переменной К тоже следует сделать преобразование и получить double:
    double K = (float)I / (double)J;      float / double = double, сами переменные при этом останутся прежних типов данных int.
    Преобразованы будут только их значения для конкретных выражений.

    (!) Не всегда знание конечного типа данных и понимание что конечный тип данных будет соответствовать даст правильный результат. */

    // Если выражение составное:
    double L = ((J / 10) + C) * D;                                          // результат будет double
    cout << "L=" << L << endl;
    /* А корректно ли оно высчиталось?  =>  Оно высчиталось неправильно!

        ((int / int) + double) * float                                      // внутри образовался неявный тип преобразования, который испортил всю картину
              1      2         3

        1: int / int = int              3 / 10 = 0                          // произошло неявное преобразование, которое мы не отследили, не подправили и получили 0
        2: int + double                 0 + 3.0 = 3.0
        3: double * float = double      3.0 * 3.14 = 9.42
        В итоге тип данных определен верно, а вот их значение высчитано неверно! Поэтому нам нужно преобразовать скобки к дробному типу данных. */

    L = (((double)J / 10) + C) * D;                                         // явное преобразование значения типа данных переменной J
    cout << "L=" << L << endl;

    /*  ((double / int) + double) * float
                 1      2         3

        1: double / int = double       3.0 / 10 = 0.33333                   // коррекция неявного преобразования, которое мы отследили, подправили и не получили 0
        2: double + double = double    0.33333 + 3.0 = 3.3333333
        3: double * float = double     3.33333 * 3.14 = 10.362

        (!) явные преобразования добавляют работы компилятору!

        Как не добавлять работы компилятору или сделать это проще? Ответ прост - преобразовать лишь литерал 10 в 10.0 */

    L = ((J / 10.0) + C) * D;                                               // неявное преобразование типа данных с помощью литерала нужного типа 10.0
    cout << "L=" << L << endl;

    /*  ((int / double) + double) * float
              1         2         3

        1: int / double = double      3 / 10.0 = 0.33333                    // коррекция неявного преобразования литералом 10.0, которое мы отследили и подправили и не
        2: double + double = double   0.33333 + 3.0 = 3.3333333             // получили 0
        3: double * float = double    3.33333 * 3.14 = 10.362               // 10.362 != 9.42 как в случае без явного преобразования!

    В 1-м варианте мы преобразовываем одну переменную, J в double, а во втором варианте, чтобы устранить прооблему неявного преобразования при делении int на int, мы
    вместо переменной преобразуем литерал 10 в double - 10.0. Во втором варианте нет никакого преобразования, а мы лишь используем литерал нужного нам типа данных.
    Преобразование произойдет только лишь при вычислении самой формулы.
    2-й вариант не требует доп.действий компилятора, мы просто в тексе программы указываем нужное число нужного нам типа и получаем корректный результат - это и есть
    корректная работа с литералами. */
}