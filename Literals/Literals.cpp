
/* Поговорим о соответствии содержимиго. Почему возникают с ним вопросы у компилятора? И зачем УИ-ю вообще придумали? Суть в том, что и число, и текст на экране и сим-
волы, которые мы видим, все это сущность языка С++, называющаяся литералами.
Литералы - это значения, указанные непосредственно в тексте программы. Эти значения не можем мы изменить, не можем их поменять, можем лишь поместить их куда-то либо вы-
вести на экран. '2' нельза положить горизонтально для примера.
Литералы - это фиксированное значение, которое программа не может поменять. Это содержимое, написанное в коде программы, цифра или буква,... (!) Не переменная и их име-
на, а именно то, что мы хотим поместить в переменную и есть литерал. Это не команды, а конкретные значения, которые мы указываем в программе. У каждого литерала есть
свой тип. Язык С++ является строго типизированным, поэтому для каждого типа данных (практически для кажлого) существуют литералы. */

#include <iostream>
#include <locale.h>

using namespace std;

int main()
{
	setlocale(LC_ALL, "rus");
	int A = 4;
	/* Значение 4 - целочисленный литерал. Переменная А инициализируется значением целочисленного литерала типы данных int.

	По умолчанию целое число имеет тип данных int, а дробное double. И когда мы объявляем переменную с другим типом данных, скажем long, компилятор сам делает коррек-
	цию, но не всегда она корректна. При наведении на '=' я увижу нужный мне тип данных. В '=' происходит преобразование типов данных, когда есть несоответствие. */
	long B = 15;
	/* Под хранение цифры 15 выделяется 4 байта, т.е. int, а мы хотим цифру 15 поместить в переменную типа long = > надо дописать буковку L/l
	long B = 15L;																		// 15L это целочисленный литерал типа long */

	long long C = 15LL;
	unsigned int D = 4U;																// u либо U добавляет к литералу приставку unsigned
	unsigned long long E = 17ULL;
	/* long long C - это мы создали объект/хранилище нужного объёма в ячейке ОЗУ, а 15LL мы хотим поместить туда содержимое нужного размера!
	У short нет своего литерала, он маленький, а у остальных есть. */

	double G = 3.14;																	// вещественные числа вычисляются с заданной точностью
	float H = 3.14F;																	// 3.14F или 3.14f - литерал типа float

	bool F = true;																		// у bool всего 2 логических литерала - true/false

	char I = 'Щ';																		// 'Щ' - символьный литерал в опострафах

	cout << "Привет Мир!" << endl;														// "Привет Мир!" - строковый литерал

	/* Т.о. мы можем литерал вывести на экран или же отправить в переменную. Литерал это само значение, которое мы указываем в коде программы. */
}