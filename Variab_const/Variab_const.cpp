#include <iostream>
#include <locale.h>
#include <stdlib.h> /* стандартная библиотека еще с языка С, содержит большое количество опций. Сейчас мы подключаем ее для очистки экрана. При подаче команды
system("cls"), почти мгновенно будет стираться все, что было выведено на экран перед этой командой. */

using namespace std;

int main()
{
    setlocale(LC_ALL, "rus");
    int A;                                                                         // переменная типа данных int для хранения целого числа
                                                                                   // и далее эта переменная должна быть инициализированна
    int B = 0;                                                                     // объявление переменной и ее инициализация нулем
    cout << B << endl;                                                             // вывод на экран значения переменной В
    A = 10;                                                                        // использование переменной и ее инициализация целым числом 10
    cout << A << endl;
    B = -17;
    cout << B << endl;
    int a = 555;
    cout << a << endl;

    double A1 = 3.14;
    cout << A1 << endl;

    int AgeOfMan = 31;
    int AgeOfWoman = 27;
    int AgeOfPerson = 45;

    system("cls");

    cout << AgeOfMan << endl;                                                      // вывод тупо числа - значения переменной

    cout << "Возраст мужчины: " << AgeOfMan << endl;                               // красивый вывод на экран с пояснением для пользователя
    cout << "Возраст женщины: " << AgeOfWoman << endl;
    cout << "Возраст человека: " << AgeOfPerson << endl;

    const float PI = 3.14;                                                         // объявление константы - обязательна инициализация сразу!
    cout << "Число Пи: " << PI << endl;                                            // (!) значение константы потом изменить уже нельзя!


    // Экспоненциальная форма записи всегда инспользуется компьютером для записи дробного числа.

    double WeightOfAtom = 2.5194e-17;                                              // чтобы преобразовать в десятичную форму записи нужно 2.5194 / 10^17
    double z = 0.000000000000000025194;
    /* Даже написав так число со всеми этими нулями после запятой, компьютер все же сам преобразует для себя это число в экспоненциальную форму
    и сохранит у себя отдельно целую часть, отдельно дробную, и отдельно экспоненциальную. Так сохраняется любое дробное число! */

    double T1 = 3.14;
    cout << T1 << endl;
    float T2 = 3.14;
    cout << T2 << endl;

    /* Float округляет до 7 знака, а double округляет до 15 знака! 3.14 и еще 13 знаков для вычисления этого числа. Но хранится всё в экспон.форме записи 3.14e+1.
    Еще раз, тип данных float занимает 4 байта, double - 8 байт.

    Если я наведу мышкой на значение float const PI, то увижу double, а когда наведу на буквы PI, то float. Система берет число double и обрезает его во float!
    Если я введу дробное число скажем в int, то компилятор дробную часть тупо обрежет без какого-либо округления, словно ножем срежет все лишнее.

    Чтобы подстраховать от ошибок, с 11 стандарта добавили возможность унифицированной инициализации (УИ). УИ включает в себя проверку соответствия типов данных.
    С ее помошью можно проверить инициализацию практически любого объекта, любой механизм языка программирования. УИ это механизм, который позволяет одинаковым образом
    задавать значения разным объектам, разным сущностям языка. Работает только при инициализации, только при создании какого-либо объекта, использовать ее для изменения
    значений при работе программы нельзя. УИ вводится фигурными скобками вокруг значения, которое необходимо унифицированно инициализировать.

    int D = { 3.14 };                                           // УИ проверила и увидела несоответствие типа данных и хранилища и не позволила запуститься программе.
    int D{3.14};                                                // второй вариант записи (БЕЗ ЗНАКА '='), также выдаст ошибку */

    int D = { 3 };
    cout << D << endl;

    system("cls");

    char Symbol = 'Ш';                                                            // Символьный тип данных. Символы указываются в опострофах по одному!
                                                                                  // а в двойных ковычках указываются наборы символов (строчки текста).
    const char Symbol2 = { 'A' };                                                 // символьная константа с УИ
    char Symbol3{ 'Г' };
    cout << "\t" << Symbol << " " << Symbol2 << ' ' << Symbol3 << endl;           // Ш А Г

    /* Пробел в кавычках воспринимается как строка, пробел в апострофах является символом! А разница - в кавычках можно писать сколько угодно пробелов как текст, а в
    апострофах лишь один. Тип данных char оперирует лишь с одним символом, два и более символa он пытается как-то преобразовать в какое-то случайное число.
    Чтобы сохранять в памяти много символов, нужны специальные конструкции (не типы данных, а наборы элементов) */
}