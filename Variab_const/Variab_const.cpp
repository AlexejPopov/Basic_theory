#include <iostream>
#include <locale.h>
#include <stdlib.h> /* стандартная библиотека еще с языка С, содержит большое количество опций. Сейчас мы подключаем ее для очистки экрана. При подаче команды
system("cls"), почти мгновенно будет стираться все, что было выведено на экран перед этой командой. */

using namespace std;

int main()
{
    setlocale(LC_ALL, "rus");
    int A;                                                                         // переменная типа данных int для хранения целого числа
                                                                                   // и далее эта переменная должна быть инициализированна
    int B = 0;                                                                     // объявление переменной и ее инициализация нулем
    cout << B << endl;                                                             // вывод на экран значения переменной В
    A = 10;                                                                        // использование переменной и ее инициализация целым числом 10
    cout << A << endl;
    B = -17;
    cout << B << endl;
    int a = 555;
    cout << a << endl;

    double A1 = 3.14;
    cout << A1 << endl;

    int AgeOfMan = 31;
    int AgeOfWoman = 27;
    int AgeOfPerson = 45;

    system("cls");

    cout << AgeOfMan << endl;                                                      // вывод тупо числа - значения переменной

    cout << "Возраст мужчины: " << AgeOfMan << endl;                               // красивый вывод на экран с пояснением для пользователя
    cout << "Возраст женщины: " << AgeOfWoman << endl;
    cout << "Возраст человека: " << AgeOfPerson << endl;

    const float PI = 3.14;                                                         // объявление константы - обязательна инициализация сразу!
    cout << "Число Пи: " << PI << endl;                                            // (!) значение константы потом изменить уже нельзя!


    // Экспоненциальная форма записи всегда инспользуется компьютером для записи дробного числа.

    double WeightOfAtom = 2.5194e-17;                                              // чтобы преобразовать в десятичную форму записи нужно 2.5194 / 10^17
    double z = 0.000000000000000025194;
    /* Даже написав так число со всеми этими нулями после запятой, компьютер все же сам преобразует для себя это число в экспоненциальную форму
    и сохранит у себя отдельно целую часть, отдельно дробную, и отдельно экспоненциальную. Так сохраняется любое дробное число! */

    double T1 = 3.14;
    cout << T1 << endl;
    float T2 = 3.14;
    cout << T2 << endl;

    /* Float округляет до 7 знака, а double округляет до 15 знака! 3.14 и еще 13 знаков для вычисления этого числа. Но хранится всё в экспон.форме записи 3.14e+1.
    Еще раз, тип данных float занимает 4 байта, double - 8 байт.

    Если я наведу мышкой на значение float const PI, то увижу double, а когда наведу на буквы PI, то float. Система берет число double и обрезает его во float!
    Если я введу дробное число скажем в int, то компилятор дробную часть тупо обрежет без какого-либо округления, словно ножем срежет все лишнее.
    Чтобы нас подстраховать от ошибок, нам с 11 стандарта добавили возможность унифицированной инициализации (УИ). С помошью неё можно инициализировать любую сущность,
    любой объект, практически любой механизм языка программирования. УИ это механизм, который позволяет одинаковым образом задавать значения разным объектам, разным
    сущностям языка.
    УИ включает в себя проверку соответствия типов данных. Работает только при инициализации, только при создании какого-либо объекта, использовать ее для изменения
    значений при работе программы нельзя. УИ вводится фигурными скобочками вокруг значения, которое необходимо унифицированно инициализировать.

    int D = { 3.14 };                                           // УИ проверила и увидела несоответствие типа данных и хранилища и не позволила запуститься программе.
    int D{3.14};                                                // второй вариант записи (БЕЗ ЗНАКА '='), также выдаст ошибку

    Вообщем это можно использовать для каждой переменной. Eсли инициализация неверная, УИ не позволит ей выполниться, а если инициализация корректна, то переменная
    выведется на экран. */

    int D = { 3 };
    cout << D << endl;

    system("cls");

    char Symbol1 = 'Ш';                                                            // Символьный тип данных. Символы указываются в опострофах по одному!
                                                                                   // а в двойных ковычках указываются наборы символов (строчки текста).
    const char Symbol2 = { 'A' };                                                  // символьная константа с УИ
    char Symbol3{ 'Г' };
    cout << "\t" << Symbol1 << " " << Symbol2 << ' ' << Symbol3 << endl;           // Ш А Г

    /* Пробел в кавычках воспринимается как строка, пробел в апострофах является символом! А разница - в кавычках можно писать сколько угодно пробелов, это текст, а в
    апострофах лишь один. Тип данных char оперирует лишь с одним символом, два и более символa он пытается как-то преобразовать в какое-то случайное число.
    Чтобы сохранять в памяти много символов, нужны специальные конструкции (не типы данных, а наборы элементов) */
}